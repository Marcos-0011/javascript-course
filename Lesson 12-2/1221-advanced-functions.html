<!DOCTYPE html>
<html>
  <head>
    <title>Advanced Functions</title>
  </head>
  <body>
    <button onclick="" class="js-button">Click</button>

    <script>
      /*
      //PART 2 OF ADVANCED FUNCTIONS PART 2
      //2.3: every HTML element has a method called .addEventListener() that lets us run some code when we interact w the element.bsically does the same thing as onclick but its better
      const buttonElement = document.querySelector('.js-button');

      const eventListener = () => {
        console.log('click');
      };

      //.addEventListener has two parameters. first one being the event or the interaction that will start the method. these events are found by looking after on, for example onclick. in this case we use click. the second parameter is a function we want to run. since we're passing a function into another function, we would use the arrow function. it does the same thing as onclick but it has some advantages. 1) it can have multiple event listeners 
      buttonElement.addEventListener('click', eventListener);
      
      //2) we can remove an event listener using method .removeEventListener() but for some reason we cant copy and paste the function, instead we have to save it into a variable to make sure its the same on line 14. then you can see it will only console.log click2s
      //due to these advantages, its better to use .addEventListener over the onclick attribute. lets go back to our projects and switch to .addEventListener. start with 122-rock-paper-scissors.js project. do the buttons w click events. then do keydown events for r, p, and s
      buttonElement.removeEventListener('click', eventListener);

      buttonElement.addEventListener('click', () => {
        console.log('click2');
      });
      */

      /*
      //PART 1: 1)review how to use functions. functions are values so we can saved them inside a variable
      //5) this type of syntax has a few advantages. its easier to read and we can hoist which mean we can call the function before creating it in the code. meaning we dont need to worry about the placement of our code in this case. however, we cant do this when we save the function into a variable
      
      function greeting() {
        console.log('hello');
      }
      greeting();

      const num = 2;

      //4) as long as there is a way to access the function, the name of the function isn't needed so delete greeting after function. this is called an anonymous function bc it doesnt have a name

      const function1 = function() {
        console.log('hello2');
      }; //2)add a semi colon here as were saving the function into a variable
      
      console.log(function1);
      console.log(typeof function1);
      function1(); //3)bc this variable contains a function, we can just call it by typing the variable and round brackets

      //6 we can also save a function into an object bc we can save a value into an object. a function inside an object is called a method and remember we dont need the function name as long as ther is another way to call the function
      const object1 = {
        num: 2,
        fun: function() {
          console.log('hello3');
        }
      };
      object1.fun();

      //7 we can also pass a value into a function
      function display(param) {
        console.log(param);
      }

      display(2);

      //8 bc functions are values, we can also pass a function into another function. the function is saved into param so now we can use it like a variable and call it using round brackets. the function were passing through is called a callback function
      function run(param) {
        param();
      }
      run(function() {
        console.log('hello4');
      });
      CONTINUE TO PART 2*/

      /*
      //PART 2: now lets do practical examples. setTimeout allows us to run a function in the future. setTimeout takes two parameters, the first one being the function we want to run in the future, the second one is how long to wait before running this function, specifically in milliseconds (1000 milliseconds is 1 second). setTimeout will set up a timer and go immediately to the next line of code. this is called asynchronous code: the computer wont wait for a line to finish before going to the next line. it'll just set up the timer and go to the next line. on the other hand, synchronous code will wait for one line to finish before going to the next line. all the code weve written in the course before is synchronous. most code we will write is synchronous. only when we use special features of JS is it when our code can become asynchronous
      setTimeout(function() {
        console.log('timeout');
        console.log('timeout2');
      }, 3000);

      console.log('next line');
      //advantage: it doesnt block our code for 3 seconds. it allows our code to do other things while the timer is running in the background. similar to a timer

      //setInterval is very similar to setTimeout, however setInterval will keep running the function after a certain period of time, in this case 3 seconds. it is also asynchronous as it moves on the next line
      setInterval(function() {
        console.log('interval');
      }, 3000);

      console.log('next line 2');
      NOW GO TO 122-ROCK-PAPER-SCISSORS FILES FOR THE AUTOPLAY FEATURE 
      AFTER GO TO PART 3 FOR MORE FEATURES OF ADVANCED FUNCTIONS*/

      /*
      //PART 3: another way to loop through an array using the forEach method. it will loop through the array by taking each value from the array and putting it in the parameter of the function. the forEach method is actually the preffered way to loop through an array as its easier to read than a loop. additionally, forEach can also grab the index of each value by taking another parameter in the function called index. now we'll do a practical example using the todo list.
      [
        'make dinner',
        'wash dishes',
        'watch youtube'
      ].forEach((value, index) => {
        //for each doesnt have continue how loops do, so if we want to skip a certain value, we would do the following code. in this case, return does the same thing as continue. it ends the function early for that value and moves on to the next value. however, if we want to exit the forEach method early, we cant use break and there is no other way to break the loop. so if break is needed, we would use a regular for loop
        if (value === 'wash dishes') {
          return;
        }

        console.log(index);
        console.log(value);
      });
      //now go to 123-todo-list-js for the practical example

      //START OF ADVANCED FUNCTIONS PART 2
      //PART 2.1: arrow functions are a shorter way to write functions. it works mostly the same as a regular function. can call it. the followng 2 syntaxes do the same thing. except the second one uses an arrow => instead of the word function. parameters works the same in where you type in the round brackets. return statements work the same way too. arrow functions have a few shortcuts that regular functions dont have. go below line 99 to see first shortcut
      const regularFunction = function(param, param2) {
        console.log('hello');
        return 5;
      }
      const arrowFunction = (param, param2) => {
        console.log('hello');
        return 5;
      };
      arrowFunction();

      //when an arrow function has 1 parameter, the round brackets are optional, so we can delete them
      const oneParam = param => {
        console.log(param + 1);
      };
      oneParam(2);

      //when an arrow function has one line, we can put the one line on the same line as the arrow. the curly brackets are also optional when there is one line, so we can delete them. we can delete the return statement too. if we just have an arrow, itll automatically return the result on the right
      const oneLine = () => 2 + 3;
      console.log(oneLine());

      //now lets get some practice using the arrow function. go up to the forEach method and use an arrow function on line 78. when we're passing a function into another function, its recommended to use arrow functions as its easier to read. then go to previous projects and use arrow functions. go to 122-rock-paper-scissors.js line 17 and use an arrow function. do the same for 123-todo-list.js line 15

      //we can also use arrow functions inside objects. the second is preffered as its easier to read. second one is called the shorthand method. scroll up to the click button 
      const object2 = {
        method: () => {

        },
        method() {

        }
      };
      */

      //ADVANCED FUNCTIONS PART 2.3: we learned the array method .forEach and now we'll learn 2 more array methods: .filter() and .map(). we'll start with filter(), lets say we have an array of numbers and want to remove all the negative numbers. filter works the same as forEach where it will take the first value of the array and save it into the value parameter and then run the function. the only difference is that filter returns a value so we'll type return true to see what happens in the new array. .filter() 1) creates a new array 2) if it returns true, it will put the value in the array 3) if it returns false, it will not put the value in the array
      console.log([1, -3, 5].filter((value, index) => {
        /*
        if (value >= 0) {
          return true;
        } else {
          return false;
        }   
        line 157 does the same as the if statement that starts at line 151 bc we can return a truthy or falsy value. next we'll learn about the method .map()*/
        return value >= 0;
      }));

      //say we have the array [1, 1, 3] and want an array with the value being doubled. .map() works the same as .forEach and .filter. .map() specifically 1) creates a new array 2) whatever we return, it will add it to the new array. in general, it will transform an array into another array. going back to the original problem of doubling the values, we can just return the value multiplied by 2. now we'll review shortcuts to arrow functions to make the code cleaner
      console.log([1, 1, 3].map((value, index) => {
        return  value * 2;
      }));

      //since we're not using index, we can delete it and bc we're using only one parameter we can delete the round brackets around value. also, if we only have one line for the arrow function, we can have the code all on one line. the curly brackets and the return are now optional. an arrow will automatically return the result. the following code does the same thing as the code on lines 161-163
      console.log([1, 1, 3].map(value => value * 2));

      //last thing we'll learn is closure which means if a function has access to a value, it will always have access to that value. we can look at todo list project as an example

      /* END:
      in this lesson we learned:
      1) functions are values
      2) setTimeout(), setInterval()
      3) .forEach()
      4) arrow functions, .addEventListener()
      5) .filter(), .map()
      6) closure
      DO EXERCISES*/
    </script>
  </body>
</html>